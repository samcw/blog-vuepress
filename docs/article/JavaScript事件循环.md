---
title: JavaScript事件循环
category: JavaScript
description: 最近作实验室技术讨论时，对于JavaScript同步异步的问题，老师及同学都有少许疑惑。几个月前，自己有所了解过相关知识，但是尚有些概念及机制不够清晰，因此整理出这篇博文，给自己加深印象。
date: 2020-03-28
---

## JavaScript事件循环

### 关于JavaScript

JavaScript是一门单线程的语言，一切的关于其多线程的概念，都是在其单线程的基础上，模拟出来的。

### 事件循环

首先辨析`JavaScript Engine`和`JavaScript runtime`的概念：

- `JavaScript Engine`：负责**解释并编译代码**，让其变成可以机器可以执行的代码。

- `JavaScript Runtime`：运行环境，提供了一些对外的调用的`api`。

要知道，引擎的执行是单线程的，这是为了防止同时去操作一个数据造成冲突或者无法判断，但是**运行环境却不是单线程的，几乎所有的异步任务都是并发的**，例如`Job Queue`、`Ajax`、`Timer`以及`node`上的`I/O`操作等等。

在讲解事件循环之前，要给一张大部分人都认同的示意图，这里借用别人的一张图：![img](https://pic3.zhimg.com/80/v2-ac509ef8768c3b157d4138ae118775d2_1440w.jpg)

看到图中，左边的部分可以看作`JavaScript Engine`。执行栈(`call Stack`)就是引擎执行代码的地方，不过这篇整理的博文，不会过多讲解执行栈的细节。

而右边的部分，注意到有个`Web APIs`，我们可以将其视为`JavaScipt Runtime`的一部分，它也一般包含了本文中，所说的`Event Table`。我们无法直接访问其线程，只能够调用它们，在浏览器中，他们是浏览器提供的各种接口，在`Node`中，它们则是`C++`提供的各种接口。

而右下的部分，则是我们这部分主要需要了解的东西——事件循环(`Event Loop`)以及任务队列(`Event Queue`)。

我们将引擎执行的一些代码，划分为两类：一种是**同步任务**，另一种是**异步任务**。

譬如，网页的渲染过程，可以看作是一些同步的任务，而对一些资源的获取，则是一些异步任务。这样做的好处，主要是为了避免堵塞，造成网页的卡顿等诸多问题。

基本上，引擎就是通过不断的作事件循环来执行代码，而执行代码的流程用一幅图来表示就是：![https://tva1.sinaimg.cn/large/00831rSTgy1gd9pru4m1nj30if0jhwfz.jpg](https://tva1.sinaimg.cn/large/00831rSTgy1gd9pru4m1nj30if0jhwfz.jpg)

当一个任务进入到了执行栈，那么大致就会进行上面的流程。

1. 一开始会先**判断任务的类型**，如果是同步任务，那么直接执行。
2. 如果是异步任务，会先交由`Event Table`挂起，当指定的事件完成，譬如，计时结束，抑或是`Ajax`返回结果，则会将其对应的回调函数，推入任务队列。
3. 如果主线程执行完毕，就会去任务队列中读取函数执行。
4. 上述的过程会不断的执行，这就是所谓的事件循环(`Event Loop`)。

举个例子：

```javascript
setTimeout(() => {
  console.log("这个setTimeout是一个异步任务");
})
console.log("这是一个同步任务");
```

执行的结果，想必我们都知道：

```shell
>>这是一个同步任务
>>这个setTimeout是一个异步任务
```

1. 主线程分析第一个任务，发现是一个异步任务，遂将这个异步任务挂起，在`Event Table`中等待，挂起这部分是由`JavaScript Runtime`托管的。
2. 由于这个异步任务的指定事件是等待，代码中设定为`0`毫秒，则挂起之后直接将其回调函数放入任务队列，等待主线程执行，它自己也从`Event Table`中被清除。
3. 主线程在处理完了`setTimeout`这个异步任务之后，继续执行任务，下一个任务是以同步任务，则直接执行，打印`>>这是一个同步任务`。
4. 接下里，主线程发现后面没有任务了，便会查看任务队列，提取函数执行。这时，就提取出来了`setTimeout`的回调函数。
5. 主线程发现回调函数里只有一个同步任务，遂直接执行，打印`>>这个setTimeout是一个异步任务`。

**注意，任务的同步及异步，是对于执行而言的。**我们对于异步任务，还有更进一步的划分。

### 事件循环的异步任务划分

我们对于异步任务，还有一个更加精细的划分：

1. **宏任务(`macro-task`)**：

   宏任务的描述有很多种，这里直接举例来说明。

   宏任务其实包括整体代码块、`setTimeout`、`setInterval`等等。

   宏任务与`DOM`任务之间，也有一定的关联，每次执行完一个宏任务后，在下一个宏任务执行前，会对页面重新渲染。

2. **微任务(`micro-task`)**：

   微任务可以理解为当前宏任务执行结束之后，立即执行的一些任务。**他们的执行是在渲染之前的。**

   微任务包括了`Promise.then`、`process.nextTick(Node)`等等。

我们除了知道哪些是宏任务，哪些是微任务以外，仅仅只需要再记住一点：**每次执行完一个宏任务之后，便会立即执行当前所有的微任务。**

**即使是在执行微任务的时候，有其他的微任务生成，也会不断执行，直到整个微任务队列清空。**

举个例子：

```javascript
console.log('1');
//宏任务set1
setTimeout(() => {
    console.log('2');
  //微任务Promise.then3
    new Promise((resolve) => {
        console.log('3');
        resolve()
    }).then(() => {
        console.log('5');
    })
}, 1000)
//微任务Promise.then1
new Promise((resolve) => {
    console.log('6');
    resolve()
}).then(() => {
    console.log('7');
})
//微任务Promise.then2
new Promise((resolve) => {
    resolve()
}).then(() => {
    console.log('8');
})
//宏任务set2
setTimeout(() => {
    console.log('9');
  //微任务Promise.then4
    new Promise((resolve) => {
        resolve()
    }).then(() => {
        console.log('10');
    })
  //微任务Promise.then5
    new Promise((resolve) => {
        console.log('11');
        resolve()
    }).then(() => {
        console.log('12');
    })
})
//宏任务set3
setTimeout(() => {
    console.log('not wait');
})
```

**注意：`Promise`非常特殊，它引入了一个新的机制，但是这里不做讨论，我们将其看成同步任务和异步任务的组合，只有`Promise.then`才是其中的异步任务，而`then`之前的代码是直接执行的同步任务。**

分析以上代码：

1. **首先，整个代码块，就是一个宏任务，主线程作事件循环的起点就是它。**

2. 主线程开始执行，第一个是同步任务，直接执行，打印`1`。接下来是一个宏任务`set1`，将其挂起，由`JavaScript Runtime`等待其计时。再接下来，是一个`Promise`，执行其第一个同步任务，打印`6`，接下来执行`resolve()`，触发其异步任务`Promise.then`，将其放入微任务队列。接下来又是一个`Promise`，同理，将其回调放入微任务队列。再接下来是一个宏任务`set2`，挂起，但是由于不需要等待，则直接将其回调放入宏任务队列，同理，接下来的`set3`也是如此。此时，整个的情况为：

   - 宏任务队列：`set2`、`set3`。
   - 微任务队列：`then1`、`then2`。
   - 挂起等待的任务：`set1`。
   - 控制台已打印：`1`、`6`。

3. 第2步执行完了一个宏任务，接下来按照规定，我们需要执行当前所有的微任务。执行`then1`，其中包含一个同步任务，直接执行，打印`7`，接下来执行`then2`，同样只包含一个同步任务，打印`8`。此时整个情况为：

   - 宏任务队列：`set2`、`set3`。
   - 微任务队列：。
   - 挂起等待的任务：`set1`。
   - 控制台已打印：`1`、`6`、`7`、`8`。

4. 接下来主线程会继续从宏任务队列取出一个宏任务执行。这里是`set2`，其回调函数第一个任务是同步任务，直接执行，打印`9`，接下来是一个`Promise`，老规矩，执行同步代码，发现其直接出发`Promise.then4`，将其放入微任务队列。接下来也是`Promise`，打印`11`，将其回调放入微任务队列，`set2`执行完毕，目前情况为：

   - 宏任务队列：`set3`。
   - 微任务队列：`then4`、`then5`。
   - 挂起等待的任务：`set1`。
   - 控制台已打印：`1`、`6`、`7`、`8`、`9`、`11`。

5. 接下来清除所有的微任务，打印`10`、`12`：

   - 宏任务队列：`set3`。
   - 微任务队列：。
   - 挂起等待的任务：`set1`
   - 控制台已打印：`1`、`6`、`7`、`8`、`9`、`11`、`10`、`12`。

6. 继续执行下一个宏任务`set3`的回调函数，打印`not wait`。

   - 宏任务队列：。
   - 微任务队列：。
   - 挂起等待的任务：`set1`。
   - 控制台已打印：`1`、`6`、`7`、`8`、`9`、`11`、`10`、`12`、`not wait`。

7. 此时，宏任务以及微任务都为空，**引擎会不断的轮询**。我们还有一个挂起的宏任务再等待，当它计时结束，其回调函数会插入宏任务队列。引擎发现宏任务队列有新的函数，开始执行。打印`2`，接下来发现一个`Promise`，打印`3`，`resolve()`触发，将其回调函数放入微任务队列。`set1`宏任务结束执行：

   - 宏任务队列：。
   - 微任务队列：`then3`。
   - 挂起等待的任务：`set1`。
   - 控制台已打印：`1`、`6`、`7`、`8`、`9`、`11`、`10`、`12`、`not wait`、`2`、`3`。

8. 接下来清空微任务队列，打印`5`。至此，所有的代码执行完毕。最终控制台打印为

   ```
   >>1
   >>6
   >>7
   >>8
   >>9
   >>11
   >>10
   >>12
   >>not wait
   >>2
   >>3
   >>5
   ```

这个执行流程，可以概括为![https://tva1.sinaimg.cn/large/00831rSTgy1gd9tlxou8jj30vu0qowhl.jpg](https://tva1.sinaimg.cn/large/00831rSTgy1gd9tlxou8jj30vu0qowhl.jpg)

### 分析Promise

实际上，`Promise`是属于一种新的机制，叫做`Job Queue`。`JavaScript Runtime`可以有多个`Job Queue`，但是只有一个`Event Queue`。

举个例子：

```javascript
console.log('执行开始');

setTimeout(() => {
 console.log('timeout') 
}, 0);

new Promise(function(resolve) {
    console.log('进入')
    resolve();
}).then(res => console.log('Promise执行完毕') )

console.log('执行结束');
```

其执行流程为：

1. 遇到同步任务，进入主线程直接执行，打印出`"执行开始"`。
2. 遇到`setTimeout`异步任务放入`Event Table`执行，满足条件后放入`Event Queue`的宏任务队列等待主线程执行。
3. 执行`Promise`，**放入`Job Queue`优先执行**，**执行同步任务打印出`"进入"`**。
4. 返回`resolve()`触发`then`回调函数，放入`Event Queue`的`微任务队列`等待主线程执行。
5. 执行同步任务打印出`"执行结束"`。
6. 主线程清空，到`Event Queue`的`微任务队列`取出任务开始执行。打印出`"Promise执行完毕"`。
7. 微任务队列清空，到宏任务队列取出任务执行，打印出`"timeout"`。

**同时，如果`Promise`存在链式回调，则执行一个回调，会将下一个回调函数推入微任务队列。**

### 总结

1. `JavaScript`的异步：

   我们从最开头就说`javascript`是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。

2. 事件循环`Event Loop`：

   事件循环是`javascript`实现异步的一种方法，也是`javascript`的执行机制。

3. `javascript`的执行和运行：

   执行和运行有很大的区别，`javascript`在不同的环境下，比如`node`，浏览器等等，执行方式是不同的。而运行大多指`javascript`解析引擎，是统一的。

4. 宏任务和微任务的种类有很多，但是执行都是有共性的。

### 参考

1. [JS基础总结—— JS执行机制与EventLoop](https://juejin.im/post/5e37de90f265da3e413f6150)

2. [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.im/post/59e85eebf265da430d571f89#heading-10)

   

